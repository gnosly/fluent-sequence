package com.gnosly.fluentsequence

import com.gnosly.fluentsequence.api.FluentSequence
import com.gnosly.fluentsequence.api.FluentSequence.FluentActor

object Main {
	def main(args: Array[String]): Unit = {
		val user = new FluentActor("user")
		val meta = new FluentActor("meta")
		val mss = new FluentActor("mss")
		val janine = new FluentActor("janine")
		val msr = new FluentActor("msr")
		val opcoRouter = new FluentActor("opco router")
		val opco = new FluentActor("opco")
		val concorde = new FluentActor("concorde")

		FluentSequence.Sequence("without concorde")
			.startWith(
				user.call("call", meta) ::
					meta.call("call", mss) ::
					mss.does("track searchIdMss autogenerated") ::
					mss.call("call", janine) ::
					janine.does("track requestIdJanine (now from db)") ::
					janine.reply("trips with requestIdJanine", mss) ::
					mss.does("track searchIdMss and requestIdJanine") ::
					mss.reply("trips", meta) ::
					meta.reply("trips", user) ::
					user.call("open deeplink with requestIdJanine and searchIdMss", msr) ::
					msr.does("take uid from casper") ::
					msr.does("track searchIdMss,requestIdJanine,externalId,uid") ::
					msr.reply("redirect to OPCO", user) ::
					user.call("open opco page", opcoRouter) ::
					opcoRouter.does("create fake request") ::
					opcoRouter.call("redirect on opco with fake request", opco) ::
					opco.does("create the booking with fake request id in ID_REQUEST field") ::
					opco.does("track bookingId and uid") ::

					Nil
			)
			.printToConsole()


		FluentSequence.Sequence("concorde")
			.startWith(
				user.call("call", meta) ::
					meta.call("call", mss) ::
					mss.does("track searchIdMss autogenerated") ::
					mss.call("call", janine) ::
					janine.does("track requestIdJanine (now from db)") ::
					janine.reply("trips with requestIdJanine", mss) ::
					mss.does("track searchIdMss and requestIdJanine") ::
					mss.reply("trips", meta) ::
					meta.reply("trips", user) ::
					user.call("open deeplink with requestIdJanine and searchIdMss", msr) ::
					msr.does("create clickIdMsr autogenerated") ::
					msr.does("track searchIdMss,requestIdJanine,clickIdMsr,externalId") ::
					msr.call("create concorde search", concorde) ::
					concorde.does("create searchIdConcorde autogenerated") ::
					concorde.reply("concorde waiting url and searchIdConcorde", msr) ::
					msr.does("track searchIdMss,requestIdJanine,clickIdMsr,externalId,searchIdConcorde") ::
					msr.reply("waiting url", user) ::
					user.call("open waiting url", concorde) ::
					concorde.call("create opco booking", opco) ::
					opco.reply("idBooking", concorde) ::
					concorde.does("track searchIdConcorde and bookingId") ::
					concorde.reply("redirect to OPCO page", user) ::
					user.call("open OPCO page", opco) ::
					Nil
			)
			.printToConsole()

		val jan = new FluentActor("janine")
		val bsa = new FluentActor("bsa")
		val mauser = new FluentActor("mauser")
		val deduplica = new FluentActor("deduplica")

		val margination = new FluentSequence.Sequence("markup").startWith(
			mauser.does("retrieve rule") ::
				mauser.does("get delta from request") ::
				mauser.does("add delta to supplement") ::
				Nil
		)

		FluentSequence.Sequence("deplica")
			.startWith(
				jan.call("search bsa", bsa) ::
					bsa.reply("trip", jan) ::
					jan.call("for each flight mark it", mauser) ::
					mauser.does(margination) ::
					mauser.reply("marked up trip",jan ) ::
					jan.does("apply supplment to Trip.leg.adultfinalAmount, child*, etc") ::
					jan.call("add each trip to deduplica", deduplica) ::
					deduplica.does("get adultAmount to compare trips") ::
					Nil
			)
			.printToConsole()
	}



	//case
	// tenere in conto minActorId e maxActorId
	// tenere in conto minSignalIndex e maxSignalIndex
	//il box deve raggruppare il max uso di attori e di segnali
}
